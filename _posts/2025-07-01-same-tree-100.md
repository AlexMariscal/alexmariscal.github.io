---
title: Leetcode Same Tree
date: 2025-07-01 14:16:00 -0400
categories: [leetcode, programming]
tags: [c++, dsa, tree, depth-first-search, dfs]
---

### Same Tree Problem
This was an easy level problem, but my first problem which used a tree.
You're given two trees which are represented by arrays.
You have to determine if the trees are exactly the same, with the same structure.
Because you have to confirm the tree's structure, 
that let me know that I needed a Depth-First Search algorithm to solve the problem.

Here's the given examples. There are a few images to illustrate the trees.
The first number is the root of the tree, and the next number is the left child, then the right child.
When a `null` is shown in an array, it means that the left child is a nullptr.
This value of `NULL` ended up being a problem for me because it has the same value as 0.
So, in these cases I pushed a value of 10<sup>4</sup> + 1 because a constraint was given as: -10<sup>4</sup> <= node.val <= 10<sup>4</sup>
```
Example 1:
Input: p = [1,2,3], q = [1,2,3]
Output: true

Example 2:
Input: p = [1,2], q = [1,null,2]
Output: false
```

### Depth-First Search
A depth-first search is an algorithm which can be used to record the structure of a tree.
It prioritizes going down a tree branch instead of going down one level at a time (a breadth-first search).
It is best to implement with recursion. There are 4 major steps to implement recursion.

1. The first step is a base case, where you have a condition to end recursion.
* In this problem, our base case is when we get to a node with a value of null.
* Because the way they represent the tree with the array input, I had to push an out of range value instead of null at the basecase
2. The next step is is a pre-recursion step, where if you have to do something before you start recursing you do it!
* Here, we record the current node's value and push it into a vector. We use it later.
3. Now is the recursion step where we recurse and run all of the same code as above until we get to the base case.
* So here, we go left first until we reach a the null pointers and record each step.
* Once we get to the base case, we return up and go right, doing the same thing.
4. Finally, we have a post step, which you do something if you need to after recursion is all done.
* We don't have a post step here, besides returning to the function that called us.

Here's the code in <b>C++</b>, hopefully the explaination above and the comments help explain everything.
```c++
/*  Definition for a binary tree node. */
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : 
        val(x), left(left), right(right) {}
};

#include<vector>
using namespace std;

void walk(TreeNode* node, vector<int>& path) {
    // recursive depth-first search
    // base case: reach a null node
    if (!node) {
        // null = 0 which is annoying
        path.push_back(10001); // -10^4 <= node.val <= 10^4
        return;
    }
    // pre: visit the node
    path.push_back(node->val);
    // recurse: walk left first
    walk(node->left, path);
    walk(node->right, path);
    // post: none
    return;
}

bool isSameTree(TreeNode* p, TreeNode* q) {
    // create vectors to hold the values of the trees
    vector<int> p_path, q_path;

    walk(p,p_path);
    walk(q,q_path);

    return (p_path == q_path) ? true : false;
}
```